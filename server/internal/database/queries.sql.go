// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addObjectTypeValue = `-- name: AddObjectTypeValue :one
INSERT INTO obj_type_value (obj_id, type_id, type_values)
SELECT $1, $2, $3::jsonb
FROM obj o
JOIN creator c ON o.creator_id = c.id
JOIN obj_type ot ON ot.creator_id = c.id
WHERE o.id = $1 AND ot.id = $2 AND c.org_id = $4
RETURNING id, obj_id, type_id, type_values, created_at, last_updated, deleted_at, search_vector
`

type AddObjectTypeValueParams struct {
	ObjID   uuid.UUID       `json:"obj_id"`
	TypeID  uuid.UUID       `json:"type_id"`
	Column3 json.RawMessage `json:"column_3"`
	OrgID   uuid.UUID       `json:"org_id"`
}

func (q *Queries) AddObjectTypeValue(ctx context.Context, arg AddObjectTypeValueParams) (ObjTypeValue, error) {
	row := q.queryRow(ctx, q.addObjectTypeValueStmt, addObjectTypeValue,
		arg.ObjID,
		arg.TypeID,
		arg.Column3,
		arg.OrgID,
	)
	var i ObjTypeValue
	err := row.Scan(
		&i.ID,
		&i.ObjID,
		&i.TypeID,
		&i.TypeValues,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
		&i.SearchVector,
	)
	return i, err
}

const addObjectsToFact = `-- name: AddObjectsToFact :exec
INSERT INTO obj_fact (obj_id, fact_id)
SELECT unnest($1::uuid[]), $2
WHERE EXISTS (
  SELECT 1 FROM fact f
  JOIN creator c ON f.creator_id = c.id
  WHERE f.id = $2 AND c.org_id = $3
)
AND NOT EXISTS (
  SELECT 1 FROM obj_fact
  WHERE obj_id = ANY($1::uuid[]) AND fact_id = $2
)
`

type AddObjectsToFactParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	FactID  uuid.UUID   `json:"fact_id"`
	OrgID   uuid.UUID   `json:"org_id"`
}

func (q *Queries) AddObjectsToFact(ctx context.Context, arg AddObjectsToFactParams) error {
	_, err := q.exec(ctx, q.addObjectsToFactStmt, addObjectsToFact, pq.Array(arg.Column1), arg.FactID, arg.OrgID)
	return err
}

const addObjectsToTask = `-- name: AddObjectsToTask :exec
INSERT INTO obj_task (obj_id, task_id)
SELECT unnest($1::uuid[]), $2
WHERE EXISTS (
  SELECT 1 FROM task t
  JOIN creator c ON t.creator_id = c.id
  WHERE t.id = $2 AND c.org_id = $3
)
AND NOT EXISTS (
  SELECT 1 FROM obj_task
  WHERE obj_id = ANY($1::uuid[]) AND task_id = $2
)
`

type AddObjectsToTaskParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	TaskID  uuid.UUID   `json:"task_id"`
	OrgID   uuid.UUID   `json:"org_id"`
}

func (q *Queries) AddObjectsToTask(ctx context.Context, arg AddObjectsToTaskParams) error {
	_, err := q.exec(ctx, q.addObjectsToTaskStmt, addObjectsToTask, pq.Array(arg.Column1), arg.TaskID, arg.OrgID)
	return err
}

const addTagToObject = `-- name: AddTagToObject :exec
INSERT INTO obj_tag (obj_id, tag_id)
SELECT $1, $2
FROM obj o
JOIN creator c ON o.creator_id = c.id
JOIN tag t ON t.org_id = c.org_id
WHERE o.id = $1 AND t.id = $2 AND c.org_id = $3
ON CONFLICT DO NOTHING
`

type AddTagToObjectParams struct {
	ObjID uuid.UUID `json:"obj_id"`
	TagID uuid.UUID `json:"tag_id"`
	OrgID uuid.UUID `json:"org_id"`
}

func (q *Queries) AddTagToObject(ctx context.Context, arg AddTagToObjectParams) error {
	_, err := q.exec(ctx, q.addTagToObjectStmt, addTagToObject, arg.ObjID, arg.TagID, arg.OrgID)
	return err
}

const countFactsByOrgID = `-- name: CountFactsByOrgID :one
SELECT COUNT(DISTINCT f.id)
FROM 
    fact f
JOIN 
    creator c ON f.creator_id = c.id
WHERE 
    c.org_id = $1 
    AND f.deleted_at IS NULL
    AND ($2::text = '' OR f.text ILIKE '%' || $2 || '%')
`

type CountFactsByOrgIDParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountFactsByOrgID(ctx context.Context, arg CountFactsByOrgIDParams) (int64, error) {
	row := q.queryRow(ctx, q.countFactsByOrgIDStmt, countFactsByOrgID, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFunnels = `-- name: CountFunnels :one
SELECT COUNT(*)
FROM funnel f
JOIN creator c ON c.id = f.creator_id
WHERE c.org_id = $1 AND f.deleted_at IS NULL
  AND ($2::text = '' OR (
    f.name ILIKE '%' || $2 || '%' OR
    f.description ILIKE '%' || $2 || '%' OR
    EXISTS (
      SELECT 1 FROM step s
      WHERE s.funnel_id = f.id AND (
        s.name ILIKE '%' || $2 || '%' OR
        s.definition ILIKE '%' || $2 || '%' OR
        s.example ILIKE '%' || $2 || '%' OR
        s.action ILIKE '%' || $2 || '%'
      )
    )
  ))
`

type CountFunnelsParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountFunnels(ctx context.Context, arg CountFunnelsParams) (int64, error) {
	row := q.queryRow(ctx, q.countFunnelsStmt, countFunnels, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObjectTypes = `-- name: CountObjectTypes :one
SELECT COUNT(*) 
FROM obj_type o
JOIN creator c ON o.creator_id = c.id
WHERE c.org_id = $1
  AND o.deleted_at IS NULL
  AND ($2::text = '' OR 
       o.name ILIKE '%' || $2 || '%' OR 
       o.description ILIKE '%' || $2 || '%' OR
       o.fields_search @@ to_tsquery('english', $2))
`

type CountObjectTypesParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountObjectTypes(ctx context.Context, arg CountObjectTypesParams) (int64, error) {
	row := q.queryRow(ctx, q.countObjectTypesStmt, countObjectTypes, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObjectsByOrgID = `-- name: CountObjectsByOrgID :one
SELECT COUNT(DISTINCT o.id)
FROM obj o
JOIN creator c ON o.creator_id = c.id
LEFT JOIN obj_tag ot ON o.id = ot.obj_id
LEFT JOIN tag t ON ot.tag_id = t.id
LEFT JOIN obj_type_value otv ON o.id = otv.obj_id
LEFT JOIN obj_fact of ON o.id = of.obj_id
LEFT JOIN fact f ON of.fact_id = f.id
WHERE c.org_id = $1 AND o.deleted_at IS NULL
  AND ($2 = '' OR
       to_tsvector('english', o.name || ' ' || o.description || ' ' || o.id_string) @@ to_tsquery('english', $2) OR
       to_tsvector('english', f.text) @@ to_tsquery('english', $2) OR
       otv.search_vector @@ to_tsquery('english', $2))
`

type CountObjectsByOrgIDParams struct {
	OrgID   uuid.UUID   `json:"org_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) CountObjectsByOrgID(ctx context.Context, arg CountObjectsByOrgIDParams) (int64, error) {
	row := q.queryRow(ctx, q.countObjectsByOrgIDStmt, countObjectsByOrgID, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObjectsForStep = `-- name: CountObjectsForStep :one
SELECT COUNT(DISTINCT o.id)
FROM obj o
JOIN obj_step os ON o.id = os.obj_id
WHERE os.step_id = $1 AND os.deleted_at IS NULL
  AND ($2::text = '' OR o.name ILIKE '%' || $2 || '%' OR o.description ILIKE '%' || $2 || '%')
`

type CountObjectsForStepParams struct {
	StepID  uuid.UUID `json:"step_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountObjectsForStep(ctx context.Context, arg CountObjectsForStepParams) (int64, error) {
	row := q.queryRow(ctx, q.countObjectsForStepStmt, countObjectsForStep, arg.StepID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOngoingTask = `-- name: CountOngoingTask :one
SELECT COUNT(*) c FROM task
WHERE assigned_id = $1 OR creator_id = $1 AND status in ('todo', 'doing')
`

func (q *Queries) CountOngoingTask(ctx context.Context, assignedID uuid.NullUUID) (int64, error) {
	row := q.queryRow(ctx, q.countOngoingTaskStmt, countOngoingTask, assignedID)
	var c int64
	err := row.Scan(&c)
	return c, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) 
FROM tag
WHERE org_id = $1
  AND deleted_at IS NULL
  AND ($2::text = '' OR (name ILIKE '%' || $2 || '%' OR description ILIKE '%' || $2 || '%'))
`

type CountTagsParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountTags(ctx context.Context, arg CountTagsParams) (int64, error) {
	row := q.queryRow(ctx, q.countTagsStmt, countTags, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTasksByObjectID = `-- name: CountTasksByObjectID :one
SELECT COUNT(DISTINCT t.id)
FROM 
    task t
JOIN 
    obj_task ot ON t.id = ot.task_id
WHERE 
    ot.obj_id = $1 
    AND t.deleted_at IS NULL
    AND ($2::text = '' OR (
        t.content ILIKE '%' || $2 || '%' OR
        EXISTS (
            SELECT 1 FROM creator c 
            WHERE c.id = t.creator_id AND c.username ILIKE '%' || $2 || '%'
        ) OR
        EXISTS (
            SELECT 1 FROM creator a 
            WHERE a.id = t.assigned_id AND a.username ILIKE '%' || $2 || '%'
        )
    ))
`

type CountTasksByObjectIDParams struct {
	ObjID   uuid.UUID `json:"obj_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountTasksByObjectID(ctx context.Context, arg CountTasksByObjectIDParams) (int64, error) {
	row := q.queryRow(ctx, q.countTasksByObjectIDStmt, countTasksByObjectID, arg.ObjID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTasksByOrgID = `-- name: CountTasksByOrgID :one
SELECT COUNT(*)
FROM task t
JOIN creator c ON t.creator_id = c.id
LEFT JOIN creator a ON t.assigned_id = a.id
WHERE c.org_id = $1 AND t.deleted_at IS NULL
  AND ($2::text = '' OR (
    t.content ILIKE '%' || $2 || '%' OR
    c.username ILIKE '%' || $2 || '%' OR
    a.username ILIKE '%' || $2 || '%'
  ))
`

type CountTasksByOrgIDParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

func (q *Queries) CountTasksByOrgID(ctx context.Context, arg CountTasksByOrgIDParams) (int64, error) {
	row := q.queryRow(ctx, q.countTasksByOrgIDStmt, countTasksByOrgID, arg.OrgID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTasksWithFilter = `-- name: CountTasksWithFilter :one
SELECT COUNT(DISTINCT t.id)
FROM 
    task t
WHERE 
    t.deleted_at IS NULL
    AND ((
      CASE 
        WHEN $1::uuid IS NOT NULL THEN 
          t.creator_id = $1
        ELSE 
          TRUE
        END
    )
    OR (
      CASE 
        WHEN $2::uuid IS NOT NULL THEN 
          t.assigned_id = $2
        ELSE 
          TRUE
      END
    ))
    AND (
      CASE 
        WHEN $3::text != '' THEN 
          (t.content ILIKE '%' || $3 || '%')
        ELSE 
          TRUE
      END
    )
    AND (
      CASE 
        WHEN $4::text != '' THEN
          t.status = ANY(string_to_array($4::text, ','))
        ELSE
          TRUE
      END
    )
`

type CountTasksWithFilterParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
}

func (q *Queries) CountTasksWithFilter(ctx context.Context, arg CountTasksWithFilterParams) (int64, error) {
	row := q.queryRow(ctx, q.countTasksWithFilterStmt, countTasksWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnseenFeed = `-- name: CountUnseenFeed :one
SELECT COUNT(*) c FROM feed
WHERE creator_id = $1 AND seen = false
`

func (q *Queries) CountUnseenFeed(ctx context.Context, creatorID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countUnseenFeedStmt, countUnseenFeed, creatorID)
	var c int64
	err := row.Scan(&c)
	return c, err
}

const createCreator = `-- name: CreateCreator :one
INSERT INTO creator (username, pwd, profile, role, org_id, active, created_at)
VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
RETURNING id, username, pwd, profile, role, org_id, active, created_at, deleted_at
`

type CreateCreatorParams struct {
	Username string          `json:"username"`
	Pwd      string          `json:"pwd"`
	Profile  json.RawMessage `json:"profile"`
	Role     string          `json:"role"`
	OrgID    uuid.UUID       `json:"org_id"`
	Active   bool            `json:"active"`
}

func (q *Queries) CreateCreator(ctx context.Context, arg CreateCreatorParams) (Creator, error) {
	row := q.queryRow(ctx, q.createCreatorStmt, createCreator,
		arg.Username,
		arg.Pwd,
		arg.Profile,
		arg.Role,
		arg.OrgID,
		arg.Active,
	)
	var i Creator
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createFact = `-- name: CreateFact :one

INSERT INTO fact (text, happened_at, location, creator_id)
VALUES ($1, $2, $3, $4)
RETURNING id, text, happened_at, location, creator_id, created_at, last_updated, deleted_at
`

type CreateFactParams struct {
	Text       string       `json:"text"`
	HappenedAt sql.NullTime `json:"happened_at"`
	Location   string       `json:"location"`
	CreatorID  uuid.UUID    `json:"creator_id"`
}

// Add these new queries to your existing queries.sql file
func (q *Queries) CreateFact(ctx context.Context, arg CreateFactParams) (Fact, error) {
	row := q.queryRow(ctx, q.createFactStmt, createFact,
		arg.Text,
		arg.HappenedAt,
		arg.Location,
		arg.CreatorID,
	)
	var i Fact
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.HappenedAt,
		&i.Location,
		&i.CreatorID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feed (creator_id, content, seen)
VALUES ($1, $2, $3)
RETURNING id, creator_id, content, seen, created_at, deleted_at
`

type CreateFeedParams struct {
	CreatorID uuid.UUID       `json:"creator_id"`
	Content   json.RawMessage `json:"content"`
	Seen      bool            `json:"seen"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.queryRow(ctx, q.createFeedStmt, createFeed, arg.CreatorID, arg.Content, arg.Seen)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Content,
		&i.Seen,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createFunnel = `-- name: CreateFunnel :one
INSERT INTO funnel (id, name, description, creator_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, creator_id, created_at, deleted_at
`

type CreateFunnelParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	CreatorID   uuid.UUID `json:"creator_id"`
}

func (q *Queries) CreateFunnel(ctx context.Context, arg CreateFunnelParams) (Funnel, error) {
	row := q.queryRow(ctx, q.createFunnelStmt, createFunnel,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CreatorID,
	)
	var i Funnel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createObjStep = `-- name: CreateObjStep :one
WITH new_step AS (
    INSERT INTO obj_step (obj_id, step_id, creator_id)
    SELECT $1, $2, $3
    WHERE NOT EXISTS (
        SELECT 1 FROM obj_step
        WHERE obj_id = $1 AND step_id = $2 AND deleted_at IS NULL
    )
    RETURNING id, obj_id, step_id, creator_id, sub_status, created_at, last_updated, deleted_at
),
update_old_steps AS (
    UPDATE obj_step
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE obj_id = $1
      AND step_id IN (
        SELECT id
        FROM step
        WHERE funnel_id = (SELECT funnel_id FROM step WHERE id = $2)
      )
      AND step_id != $2
      AND deleted_at IS NULL
)
SELECT id, obj_id, step_id, creator_id, sub_status, created_at, last_updated, deleted_at FROM new_step
`

type CreateObjStepParams struct {
	ObjID     uuid.UUID `json:"obj_id"`
	StepID    uuid.UUID `json:"step_id"`
	CreatorID uuid.UUID `json:"creator_id"`
}

type CreateObjStepRow struct {
	ID          uuid.UUID    `json:"id"`
	ObjID       uuid.UUID    `json:"obj_id"`
	StepID      uuid.UUID    `json:"step_id"`
	CreatorID   uuid.UUID    `json:"creator_id"`
	SubStatus   int32        `json:"sub_status"`
	CreatedAt   time.Time    `json:"created_at"`
	LastUpdated time.Time    `json:"last_updated"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
}

func (q *Queries) CreateObjStep(ctx context.Context, arg CreateObjStepParams) (CreateObjStepRow, error) {
	row := q.queryRow(ctx, q.createObjStepStmt, createObjStep, arg.ObjID, arg.StepID, arg.CreatorID)
	var i CreateObjStepRow
	err := row.Scan(
		&i.ID,
		&i.ObjID,
		&i.StepID,
		&i.CreatorID,
		&i.SubStatus,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const createObject = `-- name: CreateObject :one
INSERT INTO obj (name, description, id_string, creator_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, id_string, creator_id, created_at, deleted_at
`

type CreateObjectParams struct {
	Name        string    `json:"name"`
	Description string    `json:"description"`
	IDString    string    `json:"id_string"`
	CreatorID   uuid.UUID `json:"creator_id"`
}

func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) (Obj, error) {
	row := q.queryRow(ctx, q.createObjectStmt, createObject,
		arg.Name,
		arg.Description,
		arg.IDString,
		arg.CreatorID,
	)
	var i Obj
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IDString,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createObjectType = `-- name: CreateObjectType :one
INSERT INTO obj_type (name, description, fields, creator_id, icon)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, icon, description, fields, creator_id, created_at, deleted_at, fields_search
`

type CreateObjectTypeParams struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Fields      json.RawMessage `json:"fields"`
	CreatorID   uuid.UUID       `json:"creator_id"`
	Icon        string          `json:"icon"`
}

func (q *Queries) CreateObjectType(ctx context.Context, arg CreateObjectTypeParams) (ObjType, error) {
	row := q.queryRow(ctx, q.createObjectTypeStmt, createObjectType,
		arg.Name,
		arg.Description,
		arg.Fields,
		arg.CreatorID,
		arg.Icon,
	)
	var i ObjType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Icon,
		&i.Description,
		&i.Fields,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.FieldsSearch,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO org (name, profile, created_at)
VALUES ($1, $2, CURRENT_TIMESTAMP)
RETURNING id, name, profile, created_at, deleted_at
`

type CreateOrganizationParams struct {
	Name    string          `json:"name"`
	Profile json.RawMessage `json:"profile"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Org, error) {
	row := q.queryRow(ctx, q.createOrganizationStmt, createOrganization, arg.Name, arg.Profile)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Profile,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createStep = `-- name: CreateStep :one
INSERT INTO step (id, funnel_id, name, definition, example, action, step_order)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, funnel_id, name, definition, example, action, step_order, created_at, last_updated, deleted_at
`

type CreateStepParams struct {
	ID         uuid.UUID `json:"id"`
	FunnelID   uuid.UUID `json:"funnel_id"`
	Name       string    `json:"name"`
	Definition string    `json:"definition"`
	Example    string    `json:"example"`
	Action     string    `json:"action"`
	StepOrder  int32     `json:"step_order"`
}

func (q *Queries) CreateStep(ctx context.Context, arg CreateStepParams) (Step, error) {
	row := q.queryRow(ctx, q.createStepStmt, createStep,
		arg.ID,
		arg.FunnelID,
		arg.Name,
		arg.Definition,
		arg.Example,
		arg.Action,
		arg.StepOrder,
	)
	var i Step
	err := row.Scan(
		&i.ID,
		&i.FunnelID,
		&i.Name,
		&i.Definition,
		&i.Example,
		&i.Action,
		&i.StepOrder,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one

INSERT INTO tag (name, description, color_schema, org_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, color_schema, org_id, created_at, deleted_at
`

type CreateTagParams struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	ColorSchema json.RawMessage `json:"color_schema"`
	OrgID       uuid.UUID       `json:"org_id"`
}

// Setting/Tag section
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.queryRow(ctx, q.createTagStmt, createTag,
		arg.Name,
		arg.Description,
		arg.ColorSchema,
		arg.OrgID,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ColorSchema,
		&i.OrgID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO task (content, deadline, remind_at, status, creator_id, assigned_id, parent_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, content, deadline, remind_at, status, creator_id, assigned_id, parent_id, created_at, last_updated, deleted_at
`

type CreateTaskParams struct {
	Content    string        `json:"content"`
	Deadline   sql.NullTime  `json:"deadline"`
	RemindAt   sql.NullTime  `json:"remind_at"`
	Status     string        `json:"status"`
	CreatorID  uuid.UUID     `json:"creator_id"`
	AssignedID uuid.NullUUID `json:"assigned_id"`
	ParentID   uuid.NullUUID `json:"parent_id"`
}

// Existing queries...
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.queryRow(ctx, q.createTaskStmt, createTask,
		arg.Content,
		arg.Deadline,
		arg.RemindAt,
		arg.Status,
		arg.CreatorID,
		arg.AssignedID,
		arg.ParentID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Deadline,
		&i.RemindAt,
		&i.Status,
		&i.CreatorID,
		&i.AssignedID,
		&i.ParentID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCreator = `-- name: DeleteCreator :exec
UPDATE creator SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteCreator(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteCreatorStmt, deleteCreator, id)
	return err
}

const deleteFact = `-- name: DeleteFact :exec
UPDATE fact
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteFact(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteFactStmt, deleteFact, id)
	return err
}

const deleteFunnel = `-- name: DeleteFunnel :exec
UPDATE funnel
SET deleted_at = CURRENT_TIMESTAMP
WHERE funnel.id = $1 AND deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM obj_step os
    JOIN step s ON s.id = os.step_id
    WHERE s.funnel_id = $1
    AND os.deleted_at IS NULL
  )
`

func (q *Queries) DeleteFunnel(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteFunnelStmt, deleteFunnel, id)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
UPDATE obj SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteObjectStmt, deleteObject, id)
	return err
}

const deleteObjectType = `-- name: DeleteObjectType :execrows
UPDATE obj_type
SET deleted_at = CURRENT_TIMESTAMP
WHERE obj_type.id = $1 AND deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM obj_type_value WHERE type_id = $1
  )
`

func (q *Queries) DeleteObjectType(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteObjectTypeStmt, deleteObjectType, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteStep = `-- name: DeleteStep :exec
UPDATE step
SET deleted_at = CURRENT_TIMESTAMP
WHERE step.id = $1 AND deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM obj_step os WHERE os.step_id = $1
  )
`

func (q *Queries) DeleteStep(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteStepStmt, deleteStep, id)
	return err
}

const deleteTag = `-- name: DeleteTag :execrows
DELETE FROM tag 
WHERE id = $1 AND deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM obj_tag WHERE tag_id = $1
  )
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteTagStmt, deleteTag, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTask = `-- name: DeleteTask :exec
UPDATE task
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteTask(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTaskStmt, deleteTask, id)
	return err
}

const getCreator = `-- name: GetCreator :one
SELECT id, username, pwd, profile, role, org_id, active, created_at, deleted_at FROM creator WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCreator(ctx context.Context, id uuid.UUID) (Creator, error) {
	row := q.queryRow(ctx, q.getCreatorStmt, getCreator, id)
	var i Creator
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCreatorByID = `-- name: GetCreatorByID :one
SELECT id, username, pwd, profile, role, org_id, active, created_at, deleted_at FROM creator WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCreatorByID(ctx context.Context, id uuid.UUID) (Creator, error) {
	row := q.queryRow(ctx, q.getCreatorByIDStmt, getCreatorByID, id)
	var i Creator
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCreatorByUsername = `-- name: GetCreatorByUsername :one
SELECT c.id, c.username, c.pwd, c.profile, c.role, c.org_id, c.active, c.created_at, c.deleted_at, o.name as orgName FROM creator c
JOIN org o ON c.org_id = o.id
WHERE username = $1 AND active = $2
`

type GetCreatorByUsernameParams struct {
	Username string `json:"username"`
	Active   bool   `json:"active"`
}

type GetCreatorByUsernameRow struct {
	ID        uuid.UUID       `json:"id"`
	Username  string          `json:"username"`
	Pwd       string          `json:"pwd"`
	Profile   json.RawMessage `json:"profile"`
	Role      string          `json:"role"`
	OrgID     uuid.UUID       `json:"org_id"`
	Active    bool            `json:"active"`
	CreatedAt time.Time       `json:"created_at"`
	DeletedAt sql.NullTime    `json:"deleted_at"`
	Orgname   string          `json:"orgname"`
}

func (q *Queries) GetCreatorByUsername(ctx context.Context, arg GetCreatorByUsernameParams) (GetCreatorByUsernameRow, error) {
	row := q.queryRow(ctx, q.getCreatorByUsernameStmt, getCreatorByUsername, arg.Username, arg.Active)
	var i GetCreatorByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Orgname,
	)
	return i, err
}

const getFactByID = `-- name: GetFactByID :one
SELECT f.id, f.text, f.happened_at, f.location, f.creator_id, f.created_at, f.last_updated, f.deleted_at, c.username as creator_name
FROM fact f
JOIN creator c ON f.creator_id = c.id
WHERE f.id = $1 AND f.deleted_at IS NULL
`

type GetFactByIDRow struct {
	ID          uuid.UUID    `json:"id"`
	Text        string       `json:"text"`
	HappenedAt  sql.NullTime `json:"happened_at"`
	Location    string       `json:"location"`
	CreatorID   uuid.UUID    `json:"creator_id"`
	CreatedAt   time.Time    `json:"created_at"`
	LastUpdated time.Time    `json:"last_updated"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	CreatorName string       `json:"creator_name"`
}

func (q *Queries) GetFactByID(ctx context.Context, id uuid.UUID) (GetFactByIDRow, error) {
	row := q.queryRow(ctx, q.getFactByIDStmt, getFactByID, id)
	var i GetFactByIDRow
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.HappenedAt,
		&i.Location,
		&i.CreatorID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
		&i.CreatorName,
	)
	return i, err
}

const getFeed = `-- name: GetFeed :many
SELECT id, creator_id, content, seen, created_at, deleted_at FROM feed
WHERE creator_id = $1 AND seen = false
ORDER BY created_at DESC
LIMIT 10
`

func (q *Queries) GetFeed(ctx context.Context, creatorID uuid.UUID) ([]Feed, error) {
	rows, err := q.query(ctx, q.getFeedStmt, getFeed, creatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Content,
			&i.Seen,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunnel = `-- name: GetFunnel :one
SELECT f.id, f.name, f.description, f.creator_id, f.created_at, f.deleted_at, c.org_id,
       (SELECT COUNT(*) FROM obj_step os
        JOIN step s ON s.id = os.step_id
        WHERE s.funnel_id = f.id) AS object_count
FROM funnel f
JOIN creator c ON c.id = f.creator_id
WHERE f.id = $1 AND f.deleted_at IS NULL
`

type GetFunnelRow struct {
	ID          uuid.UUID    `json:"id"`
	Name        string       `json:"name"`
	Description string       `json:"description"`
	CreatorID   uuid.UUID    `json:"creator_id"`
	CreatedAt   time.Time    `json:"created_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	OrgID       uuid.UUID    `json:"org_id"`
	ObjectCount int64        `json:"object_count"`
}

func (q *Queries) GetFunnel(ctx context.Context, id uuid.UUID) (GetFunnelRow, error) {
	row := q.queryRow(ctx, q.getFunnelStmt, getFunnel, id)
	var i GetFunnelRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.OrgID,
		&i.ObjectCount,
	)
	return i, err
}

const getObjStep = `-- name: GetObjStep :one
SELECT id, obj_id, step_id, creator_id, sub_status, created_at, last_updated, deleted_at FROM obj_step
WHERE id = $1
`

func (q *Queries) GetObjStep(ctx context.Context, id uuid.UUID) (ObjStep, error) {
	row := q.queryRow(ctx, q.getObjStepStmt, getObjStep, id)
	var i ObjStep
	err := row.Scan(
		&i.ID,
		&i.ObjID,
		&i.StepID,
		&i.CreatorID,
		&i.SubStatus,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const getObjectDetails = `-- name: GetObjectDetails :one
WITH object_data AS (
    SELECT o.id, o.name, o.description, o.id_string, o.creator_id, o.created_at,
           c.org_id,
           coalesce(
            json_agg(DISTINCT jsonb_build_object('id', t.id, 'name', t.name, 'color_schema', t.color_schema)) FILTER (WHERE t.id IS NOT NULL), '[]') 
           AS tags,
           coalesce(json_agg(DISTINCT jsonb_build_object(
               'id', otv.id,
               'objectTypeId', ot.id,
               'objectTypeName', ot.name,
               'objectTypeIcon', ot.icon,
               'objectTypeFields', ot.fields,
               'type_values', otv.type_values
           )) FILTER (WHERE otv.id IS NOT NULL), '[]')
           AS type_values,
           coalesce(json_agg(DISTINCT jsonb_build_object(
               'id', task.id,
               'content', task.content,
               'deadline', task.deadline,
               'status', task.status,
               'createdAt', task.created_at,
               'assignedId', task.assigned_id
           )) FILTER (WHERE task.id IS NOT NULL), '[]')
           AS tasks,
           coalesce(json_agg(DISTINCT jsonb_build_object(
               'stepId', s.id,
               'stepName', s.name,
               'funnelId', f.id,
               'funnelName', f.name,
               'subStatus', os.sub_status,
               'createdAt', os.created_at,
               'deletedAt', os.deleted_at,
               'id', os.id
           )) FILTER (WHERE s.id IS NOT NULL), '[]')
           AS steps_and_funnels,
           coalesce(json_agg(DISTINCT jsonb_build_object(
               'id', fact.id,
               'text', fact.text,
               'happenedAt', fact.happened_at,
               'location', fact.location,
               'createdAt', fact.created_at
           )) FILTER (WHERE fact.id IS NOT NULL), '[]')
           AS facts
    FROM obj o
    JOIN creator c ON o.creator_id = c.id
    LEFT JOIN obj_tag otg ON o.id = otg.obj_id
    LEFT JOIN tag t ON otg.tag_id = t.id
    LEFT JOIN obj_type_value otv ON o.id = otv.obj_id
    LEFT JOIN obj_type ot ON otv.type_id = ot.id
    LEFT JOIN obj_task ota ON o.id = ota.obj_id
    LEFT JOIN task ON ota.task_id = task.id
    LEFT JOIN obj_step os ON o.id = os.obj_id
    LEFT JOIN step s ON os.step_id = s.id
    LEFT JOIN funnel f ON s.funnel_id = f.id
    LEFT JOIN obj_fact of ON o.id = of.obj_id
    LEFT JOIN fact ON of.fact_id = fact.id
    WHERE o.id = $1 AND c.org_id = $2
    GROUP BY o.id, o.name, o.description, o.id_string, o.creator_id, o.created_at, c.org_id
)
SELECT id, name, description, id_string, creator_id, created_at, org_id, tags, type_values, tasks, steps_and_funnels, facts
FROM object_data
`

type GetObjectDetailsParams struct {
	ID    uuid.UUID `json:"id"`
	OrgID uuid.UUID `json:"org_id"`
}

type GetObjectDetailsRow struct {
	ID              uuid.UUID   `json:"id"`
	Name            string      `json:"name"`
	Description     string      `json:"description"`
	IDString        string      `json:"id_string"`
	CreatorID       uuid.UUID   `json:"creator_id"`
	CreatedAt       time.Time   `json:"created_at"`
	OrgID           uuid.UUID   `json:"org_id"`
	Tags            interface{} `json:"tags"`
	TypeValues      interface{} `json:"type_values"`
	Tasks           interface{} `json:"tasks"`
	StepsAndFunnels interface{} `json:"steps_and_funnels"`
	Facts           interface{} `json:"facts"`
}

func (q *Queries) GetObjectDetails(ctx context.Context, arg GetObjectDetailsParams) (GetObjectDetailsRow, error) {
	row := q.queryRow(ctx, q.getObjectDetailsStmt, getObjectDetails, arg.ID, arg.OrgID)
	var i GetObjectDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IDString,
		&i.CreatorID,
		&i.CreatedAt,
		&i.OrgID,
		&i.Tags,
		&i.TypeValues,
		&i.Tasks,
		&i.StepsAndFunnels,
		&i.Facts,
	)
	return i, err
}

const getObjectTypeByID = `-- name: GetObjectTypeByID :one
SELECT id, name, icon, description, fields, creator_id, created_at, deleted_at, fields_search FROM obj_type
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetObjectTypeByID(ctx context.Context, id uuid.UUID) (ObjType, error) {
	row := q.queryRow(ctx, q.getObjectTypeByIDStmt, getObjectTypeByID, id)
	var i ObjType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Icon,
		&i.Description,
		&i.Fields,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.FieldsSearch,
	)
	return i, err
}

const getObjectsForStep = `-- name: GetObjectsForStep :many
SELECT o.id, o.name, o.description,
       coalesce(json_agg(json_build_object('id', t.id, 'name', t.name, 'color_schema', t.color_schema)) FILTER (WHERE t.id IS NOT NULL), '[]') AS tags
FROM obj o
JOIN obj_step os ON o.id = os.obj_id
LEFT JOIN obj_tag ot ON o.id = ot.obj_id
LEFT JOIN tag t ON ot.tag_id = t.id
WHERE os.step_id = $1 AND os.deleted_at IS NULL
  AND ($2::text = '' OR o.name ILIKE '%' || $2 || '%' OR o.description ILIKE '%' || $2 || '%')
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT $3 OFFSET $4
`

type GetObjectsForStepParams struct {
	StepID  uuid.UUID `json:"step_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type GetObjectsForStepRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Tags        interface{} `json:"tags"`
}

func (q *Queries) GetObjectsForStep(ctx context.Context, arg GetObjectsForStepParams) ([]GetObjectsForStepRow, error) {
	rows, err := q.query(ctx, q.getObjectsForStepStmt, getObjectsForStep,
		arg.StepID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsForStepRow
	for rows.Next() {
		var i GetObjectsForStepRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgDetails = `-- name: GetOrgDetails :one
SELECT id, name, profile, created_at, deleted_at FROM org WHERE id = $1
`

func (q *Queries) GetOrgDetails(ctx context.Context, id uuid.UUID) (Org, error) {
	row := q.queryRow(ctx, q.getOrgDetailsStmt, getOrgDetails, id)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Profile,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStep = `-- name: GetStep :one
SELECT s.id, s.funnel_id, s.name, s.definition, s.example, s.action, s.step_order, s.created_at, s.last_updated, s.deleted_at, f.name AS funnel_name, 
       (SELECT COUNT(*) FROM obj_step os WHERE os.step_id = s.id) AS object_count
FROM step s
JOIN funnel f ON s.funnel_id = f.id
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetStepRow struct {
	ID          uuid.UUID    `json:"id"`
	FunnelID    uuid.UUID    `json:"funnel_id"`
	Name        string       `json:"name"`
	Definition  string       `json:"definition"`
	Example     string       `json:"example"`
	Action      string       `json:"action"`
	StepOrder   int32        `json:"step_order"`
	CreatedAt   time.Time    `json:"created_at"`
	LastUpdated time.Time    `json:"last_updated"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	FunnelName  string       `json:"funnel_name"`
	ObjectCount int64        `json:"object_count"`
}

func (q *Queries) GetStep(ctx context.Context, id uuid.UUID) (GetStepRow, error) {
	row := q.queryRow(ctx, q.getStepStmt, getStep, id)
	var i GetStepRow
	err := row.Scan(
		&i.ID,
		&i.FunnelID,
		&i.Name,
		&i.Definition,
		&i.Example,
		&i.Action,
		&i.StepOrder,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
		&i.FunnelName,
		&i.ObjectCount,
	)
	return i, err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, description, color_schema, org_id, created_at, deleted_at FROM tag
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetTagByID(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.queryRow(ctx, q.getTagByIDStmt, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ColorSchema,
		&i.OrgID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT t.id, t.content, t.deadline, t.remind_at, t.status, t.creator_id, t.assigned_id, t.parent_id, t.created_at, t.last_updated, t.deleted_at, c.username as creator_name, a.username as assigned_name
FROM task t
JOIN creator c ON t.creator_id = c.id
LEFT JOIN creator a ON t.assigned_id = a.id
WHERE t.id = $1 AND t.deleted_at IS NULL
`

type GetTaskByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Content      string         `json:"content"`
	Deadline     sql.NullTime   `json:"deadline"`
	RemindAt     sql.NullTime   `json:"remind_at"`
	Status       string         `json:"status"`
	CreatorID    uuid.UUID      `json:"creator_id"`
	AssignedID   uuid.NullUUID  `json:"assigned_id"`
	ParentID     uuid.NullUUID  `json:"parent_id"`
	CreatedAt    time.Time      `json:"created_at"`
	LastUpdated  time.Time      `json:"last_updated"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	CreatorName  string         `json:"creator_name"`
	AssignedName sql.NullString `json:"assigned_name"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id uuid.UUID) (GetTaskByIDRow, error) {
	row := q.queryRow(ctx, q.getTaskByIDStmt, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Deadline,
		&i.RemindAt,
		&i.Status,
		&i.CreatorID,
		&i.AssignedID,
		&i.ParentID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
		&i.CreatorName,
		&i.AssignedName,
	)
	return i, err
}

const hardDeleteObjStep = `-- name: HardDeleteObjStep :exec
DELETE FROM obj_step
WHERE id = $1
`

func (q *Queries) HardDeleteObjStep(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.hardDeleteObjStepStmt, hardDeleteObjStep, id)
	return err
}

const listFactsByOrgID = `-- name: ListFactsByOrgID :many
SELECT 
    f.id,
    f.text,
    f.happened_at,
    f.location,
    f.creator_id,
    c.username AS creator_name,
    f.created_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', o.id,
                'name', o.name,
                'description', o.description
            )
        ) FILTER (WHERE o.id IS NOT NULL),
        '[]'
    ) AS related_objects
FROM 
    fact f
JOIN 
    creator c ON f.creator_id = c.id
LEFT JOIN 
    obj_fact of ON f.id = of.fact_id
LEFT JOIN 
    obj o ON of.obj_id = o.id
WHERE 
    c.org_id = $1 
    AND f.deleted_at IS NULL
    AND ($2::text = '' OR f.text ILIKE '%' || $2 || '%')
GROUP BY 
    f.id, c.username
ORDER BY 
    f.happened_at DESC
LIMIT $3 OFFSET $4
`

type ListFactsByOrgIDParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListFactsByOrgIDRow struct {
	ID             uuid.UUID    `json:"id"`
	Text           string       `json:"text"`
	HappenedAt     sql.NullTime `json:"happened_at"`
	Location       string       `json:"location"`
	CreatorID      uuid.UUID    `json:"creator_id"`
	CreatorName    string       `json:"creator_name"`
	CreatedAt      time.Time    `json:"created_at"`
	RelatedObjects interface{}  `json:"related_objects"`
}

func (q *Queries) ListFactsByOrgID(ctx context.Context, arg ListFactsByOrgIDParams) ([]ListFactsByOrgIDRow, error) {
	rows, err := q.query(ctx, q.listFactsByOrgIDStmt, listFactsByOrgID,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFactsByOrgIDRow
	for rows.Next() {
		var i ListFactsByOrgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.HappenedAt,
			&i.Location,
			&i.CreatorID,
			&i.CreatorName,
			&i.CreatedAt,
			&i.RelatedObjects,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFunnels = `-- name: ListFunnels :many
SELECT f.id, f.name, f.description, f.creator_id, f.created_at, f.deleted_at, c.org_id,
       (SELECT COUNT(*) FROM obj_step os
        JOIN step s ON s.id = os.step_id
        WHERE s.funnel_id = f.id) AS object_count
FROM funnel f
JOIN creator c ON c.id = f.creator_id
WHERE c.org_id = $1 AND f.deleted_at IS NULL
  AND ($2::text = '' OR (
    f.name ILIKE '%' || $2 || '%' OR
    f.description ILIKE '%' || $2 || '%' OR
    EXISTS (
      SELECT 1 FROM step s
      WHERE s.funnel_id = f.id AND (
        s.name ILIKE '%' || $2 || '%' OR
        s.definition ILIKE '%' || $2 || '%' OR
        s.example ILIKE '%' || $2 || '%' OR
        s.action ILIKE '%' || $2 || '%'
      )
    )
  ))
ORDER BY f.created_at DESC
LIMIT $3 OFFSET $4
`

type ListFunnelsParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListFunnelsRow struct {
	ID          uuid.UUID    `json:"id"`
	Name        string       `json:"name"`
	Description string       `json:"description"`
	CreatorID   uuid.UUID    `json:"creator_id"`
	CreatedAt   time.Time    `json:"created_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	OrgID       uuid.UUID    `json:"org_id"`
	ObjectCount int64        `json:"object_count"`
}

func (q *Queries) ListFunnels(ctx context.Context, arg ListFunnelsParams) ([]ListFunnelsRow, error) {
	rows, err := q.query(ctx, q.listFunnelsStmt, listFunnels,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFunnelsRow
	for rows.Next() {
		var i ListFunnelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatorID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.OrgID,
			&i.ObjectCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectTypes = `-- name: ListObjectTypes :many
SELECT o.id, o.name, o.icon, o.description, o.fields, o.created_at
FROM obj_type o
JOIN creator c ON o.creator_id = c.id
WHERE c.org_id = $1
  AND o.deleted_at IS NULL
  AND ($2::text = '' OR 
       o.name ILIKE '%' || $2 || '%' OR 
       o.description ILIKE '%' || $2 || '%' OR
       o.fields_search @@ to_tsquery('english', $2))
ORDER BY o.created_at DESC
LIMIT $3 OFFSET $4
`

type ListObjectTypesParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListObjectTypesRow struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Icon        string          `json:"icon"`
	Description string          `json:"description"`
	Fields      json.RawMessage `json:"fields"`
	CreatedAt   time.Time       `json:"created_at"`
}

func (q *Queries) ListObjectTypes(ctx context.Context, arg ListObjectTypesParams) ([]ListObjectTypesRow, error) {
	rows, err := q.query(ctx, q.listObjectTypesStmt, listObjectTypes,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListObjectTypesRow
	for rows.Next() {
		var i ListObjectTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Icon,
			&i.Description,
			&i.Fields,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByOrgID = `-- name: ListObjectsByOrgID :many
WITH object_data AS (
    SELECT o.id, o.name, o.description, o.id_string, o.creator_id,
           o.created_at, o.deleted_at,
           to_tsvector('english', o.name || ' ' || o.description || ' ' || o.id_string) AS obj_search,
           array_agg(DISTINCT t.id) AS tag_ids,
           array_agg(DISTINCT otv.id) AS type_value_ids,
           string_agg(DISTINCT otv.search_vector::text, ' ')::tsvector AS type_search,
           string_agg(DISTINCT f.text::text, ' ')::text AS fact_search
    FROM obj o
    JOIN creator c ON o.creator_id = c.id
    LEFT JOIN obj_tag ot ON o.id = ot.obj_id
    LEFT JOIN tag t ON ot.tag_id = t.id
    LEFT JOIN obj_type_value otv ON o.id = otv.obj_id
    LEFT JOIN obj_fact of ON o.id = of.obj_id
    LEFT JOIN fact f ON of.fact_id = f.id
    WHERE c.org_id = $1 AND o.deleted_at IS NULL
    GROUP BY o.id
)
SELECT od.id, od.name, od.description, od.id_string, od.created_at,
       coalesce((SELECT jsonb_agg(jsonb_build_object('id', t.id, 'name', t.name, 'color_schema', t.color_schema))
        FROM tag t
        WHERE t.id = ANY(od.tag_ids)),'[]') AS tags,
       coalesce((SELECT jsonb_agg(jsonb_build_object('id', otv.id, 'objectTypeId', otv.type_id, 'type_values', otv.type_values))
        FROM obj_type_value otv
        WHERE otv.id = ANY(od.type_value_ids)),'[]') AS type_values
FROM object_data od
WHERE ($2 = '' OR
      od.obj_search @@ to_tsquery('english', $2) OR
      od.fact_search @@ to_tsquery('english', $2) OR
      od.type_search @@ to_tsquery('english', $2)
      )
ORDER BY od.created_at DESC
LIMIT $3 OFFSET $4
`

type ListObjectsByOrgIDParams struct {
	OrgID   uuid.UUID   `json:"org_id"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListObjectsByOrgIDRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	IDString    string      `json:"id_string"`
	CreatedAt   time.Time   `json:"created_at"`
	Tags        interface{} `json:"tags"`
	TypeValues  interface{} `json:"type_values"`
}

func (q *Queries) ListObjectsByOrgID(ctx context.Context, arg ListObjectsByOrgIDParams) ([]ListObjectsByOrgIDRow, error) {
	rows, err := q.query(ctx, q.listObjectsByOrgIDStmt, listObjectsByOrgID,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListObjectsByOrgIDRow
	for rows.Next() {
		var i ListObjectsByOrgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IDString,
			&i.CreatedAt,
			&i.Tags,
			&i.TypeValues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByTaskID = `-- name: ListObjectsByTaskID :many
SELECT o.id, o.name, o.description
FROM obj o
JOIN obj_task ot ON o.id = ot.obj_id
WHERE ot.task_id = $1
`

type ListObjectsByTaskIDRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
}

func (q *Queries) ListObjectsByTaskID(ctx context.Context, taskID uuid.UUID) ([]ListObjectsByTaskIDRow, error) {
	rows, err := q.query(ctx, q.listObjectsByTaskIDStmt, listObjectsByTaskID, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListObjectsByTaskIDRow
	for rows.Next() {
		var i ListObjectsByTaskIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrgMembers = `-- name: ListOrgMembers :many
WITH filtered_creators AS (
    SELECT c.id, c.username, c.profile, c.role, c.active, c.created_at,
           to_tsvector('english', c.username) || 
           to_tsvector('english', coalesce(c.profile::text, '')) as document
    FROM creator c
    WHERE c.org_id = $1 AND c.deleted_at IS NULL
)
SELECT id, username, profile, role, active, created_at
FROM filtered_creators
WHERE $2::text = '' OR 
      document @@ plainto_tsquery('english', $2::text) OR
      profile::text ILIKE '%' || $2::text || '%'
ORDER BY created_at DESC
`

type ListOrgMembersParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
}

type ListOrgMembersRow struct {
	ID        uuid.UUID       `json:"id"`
	Username  string          `json:"username"`
	Profile   json.RawMessage `json:"profile"`
	Role      string          `json:"role"`
	Active    bool            `json:"active"`
	CreatedAt time.Time       `json:"created_at"`
}

func (q *Queries) ListOrgMembers(ctx context.Context, arg ListOrgMembersParams) ([]ListOrgMembersRow, error) {
	rows, err := q.query(ctx, q.listOrgMembersStmt, listOrgMembers, arg.OrgID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrgMembersRow
	for rows.Next() {
		var i ListOrgMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Profile,
			&i.Role,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsByFunnel = `-- name: ListStepsByFunnel :many
SELECT s.id, s.funnel_id, s.name, s.definition, s.example, s.action, s.step_order, s.created_at, s.last_updated, s.deleted_at, 
       (SELECT COUNT(*) FROM obj_step os WHERE os.step_id = s.id) AS object_count
FROM step s
WHERE s.funnel_id = $1 AND s.deleted_at IS NULL
ORDER BY s.step_order
`

type ListStepsByFunnelRow struct {
	ID          uuid.UUID    `json:"id"`
	FunnelID    uuid.UUID    `json:"funnel_id"`
	Name        string       `json:"name"`
	Definition  string       `json:"definition"`
	Example     string       `json:"example"`
	Action      string       `json:"action"`
	StepOrder   int32        `json:"step_order"`
	CreatedAt   time.Time    `json:"created_at"`
	LastUpdated time.Time    `json:"last_updated"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	ObjectCount int64        `json:"object_count"`
}

func (q *Queries) ListStepsByFunnel(ctx context.Context, funnelID uuid.UUID) ([]ListStepsByFunnelRow, error) {
	rows, err := q.query(ctx, q.listStepsByFunnelStmt, listStepsByFunnel, funnelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStepsByFunnelRow
	for rows.Next() {
		var i ListStepsByFunnelRow
		if err := rows.Scan(
			&i.ID,
			&i.FunnelID,
			&i.Name,
			&i.Definition,
			&i.Example,
			&i.Action,
			&i.StepOrder,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.DeletedAt,
			&i.ObjectCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT t.id, t.name, t.description, t.color_schema, t.created_at
FROM tag t
WHERE t.org_id = $1
  AND t.deleted_at IS NULL
  AND ($2::text = '' OR (t.name ILIKE '%' || $2 || '%' OR t.description ILIKE '%' || $2 || '%'))
ORDER BY t.created_at DESC
LIMIT $3 OFFSET $4
`

type ListTagsParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListTagsRow struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	ColorSchema json.RawMessage `json:"color_schema"`
	CreatedAt   time.Time       `json:"created_at"`
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]ListTagsRow, error) {
	rows, err := q.query(ctx, q.listTagsStmt, listTags,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsRow
	for rows.Next() {
		var i ListTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ColorSchema,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByObjectID = `-- name: ListTasksByObjectID :many
SELECT 
    t.id,
    t.content,
    t.deadline,
    t.remind_at,
    t.status,
    t.creator_id,
    c.username AS creator_name,
    t.assigned_id,
    a.username AS assigned_name,
    t.parent_id,
    t.created_at,
    t.last_updated,
    COALESCE(
        json_agg(
            json_build_object(
                'id', o.id,
                'name', o.name,
                'description', o.description
            )
        ) FILTER (WHERE o.id IS NOT NULL),
        '[]'
    ) AS objects
FROM 
    task t
JOIN 
    creator c ON t.creator_id = c.id
LEFT JOIN 
    creator a ON t.assigned_id = a.id
JOIN 
    obj_task ot ON t.id = ot.task_id
LEFT JOIN 
    obj o ON ot.obj_id = o.id
WHERE 
    o.id = $1 
    AND t.deleted_at IS NULL
    AND ($2::text = '' OR (
        t.content ILIKE '%' || $2 || '%' OR
        c.username ILIKE '%' || $2 || '%' OR
        a.username ILIKE '%' || $2 || '%'
    ))
GROUP BY 
    t.id, c.username, a.username
ORDER BY 
    t.created_at DESC
LIMIT $3 OFFSET $4
`

type ListTasksByObjectIDParams struct {
	ID      uuid.UUID `json:"id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListTasksByObjectIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Content      string         `json:"content"`
	Deadline     sql.NullTime   `json:"deadline"`
	RemindAt     sql.NullTime   `json:"remind_at"`
	Status       string         `json:"status"`
	CreatorID    uuid.UUID      `json:"creator_id"`
	CreatorName  string         `json:"creator_name"`
	AssignedID   uuid.NullUUID  `json:"assigned_id"`
	AssignedName sql.NullString `json:"assigned_name"`
	ParentID     uuid.NullUUID  `json:"parent_id"`
	CreatedAt    time.Time      `json:"created_at"`
	LastUpdated  time.Time      `json:"last_updated"`
	Objects      interface{}    `json:"objects"`
}

func (q *Queries) ListTasksByObjectID(ctx context.Context, arg ListTasksByObjectIDParams) ([]ListTasksByObjectIDRow, error) {
	rows, err := q.query(ctx, q.listTasksByObjectIDStmt, listTasksByObjectID,
		arg.ID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByObjectIDRow
	for rows.Next() {
		var i ListTasksByObjectIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Deadline,
			&i.RemindAt,
			&i.Status,
			&i.CreatorID,
			&i.CreatorName,
			&i.AssignedID,
			&i.AssignedName,
			&i.ParentID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Objects,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByOrgID = `-- name: ListTasksByOrgID :many
SELECT t.id, t.content, t.deadline, t.remind_at, t.status, t.creator_id, t.assigned_id, t.parent_id, t.created_at, t.last_updated, t.deleted_at, c.username as creator_name, a.username as assigned_name
FROM task t
JOIN creator c ON t.creator_id = c.id
LEFT JOIN creator a ON t.assigned_id = a.id
WHERE c.org_id = $1 AND t.deleted_at IS NULL
  AND ($2::text = '' OR (
    t.content ILIKE '%' || $2 || '%' OR
    c.username ILIKE '%' || $2 || '%' OR
    a.username ILIKE '%' || $2 || '%'
  ))
ORDER BY t.last_updated DESC
LIMIT $3 OFFSET $4
`

type ListTasksByOrgIDParams struct {
	OrgID   uuid.UUID `json:"org_id"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListTasksByOrgIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Content      string         `json:"content"`
	Deadline     sql.NullTime   `json:"deadline"`
	RemindAt     sql.NullTime   `json:"remind_at"`
	Status       string         `json:"status"`
	CreatorID    uuid.UUID      `json:"creator_id"`
	AssignedID   uuid.NullUUID  `json:"assigned_id"`
	ParentID     uuid.NullUUID  `json:"parent_id"`
	CreatedAt    time.Time      `json:"created_at"`
	LastUpdated  time.Time      `json:"last_updated"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	CreatorName  string         `json:"creator_name"`
	AssignedName sql.NullString `json:"assigned_name"`
}

func (q *Queries) ListTasksByOrgID(ctx context.Context, arg ListTasksByOrgIDParams) ([]ListTasksByOrgIDRow, error) {
	rows, err := q.query(ctx, q.listTasksByOrgIDStmt, listTasksByOrgID,
		arg.OrgID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByOrgIDRow
	for rows.Next() {
		var i ListTasksByOrgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Deadline,
			&i.RemindAt,
			&i.Status,
			&i.CreatorID,
			&i.AssignedID,
			&i.ParentID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.DeletedAt,
			&i.CreatorName,
			&i.AssignedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksWithFilter = `-- name: ListTasksWithFilter :many

SELECT 
    t.id,
    t.content,
    t.deadline,
    t.remind_at,
    t.status,
    t.creator_id,
    c.username AS creator_name,
    t.assigned_id,
    a.username AS assigned_name,
    t.parent_id,
    t.created_at,
    t.last_updated,
    COALESCE(
        json_agg(
            json_build_object(
                'id', o.id,
                'name', o.name,
                'description', o.description
            )
        ) FILTER (WHERE o.id IS NOT NULL),
        '[]'
    ) AS objects
FROM 
    task t
JOIN 
    creator c ON t.creator_id = c.id
LEFT JOIN 
    creator a ON t.assigned_id = a.id
LEFT JOIN 
    obj_task ot ON t.id = ot.task_id
LEFT JOIN 
    obj o ON ot.obj_id = o.id
WHERE 
    t.deleted_at IS NULL
    AND ((
      CASE 
        WHEN $1::uuid IS NOT NULL THEN 
          t.creator_id = $1
        ELSE 
          TRUE
      END
    )
    OR (
      CASE 
        WHEN $2::uuid IS NOT NULL THEN 
          t.assigned_id = $2
        ELSE 
          TRUE
      END
    ))
    AND (
      CASE 
        WHEN $3::text != '' THEN 
          (t.content ILIKE '%' || $3 || '%')
        ELSE 
          TRUE
      END
    )
    AND (
      CASE 
        WHEN $4::text != '' THEN
          t.status = ANY(string_to_array($4::text, ','))
        ELSE
          TRUE
      END
    )
GROUP BY 
    t.id, c.username, a.username
ORDER BY 
    t.last_updated DESC
LIMIT $5 OFFSET $6
`

type ListTasksWithFilterParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListTasksWithFilterRow struct {
	ID           uuid.UUID      `json:"id"`
	Content      string         `json:"content"`
	Deadline     sql.NullTime   `json:"deadline"`
	RemindAt     sql.NullTime   `json:"remind_at"`
	Status       string         `json:"status"`
	CreatorID    uuid.UUID      `json:"creator_id"`
	CreatorName  string         `json:"creator_name"`
	AssignedID   uuid.NullUUID  `json:"assigned_id"`
	AssignedName sql.NullString `json:"assigned_name"`
	ParentID     uuid.NullUUID  `json:"parent_id"`
	CreatedAt    time.Time      `json:"created_at"`
	LastUpdated  time.Time      `json:"last_updated"`
	Objects      interface{}    `json:"objects"`
}

// Add this new query to your existing queries.sql file
func (q *Queries) ListTasksWithFilter(ctx context.Context, arg ListTasksWithFilterParams) ([]ListTasksWithFilterRow, error) {
	rows, err := q.query(ctx, q.listTasksWithFilterStmt, listTasksWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksWithFilterRow
	for rows.Next() {
		var i ListTasksWithFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Deadline,
			&i.RemindAt,
			&i.Status,
			&i.CreatorID,
			&i.CreatorName,
			&i.AssignedID,
			&i.AssignedName,
			&i.ParentID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Objects,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedAsSeen = `-- name: MarkFeedAsSeen :exec
UPDATE feed
SET seen = true
WHERE id = ANY($1::uuid[])
`

func (q *Queries) MarkFeedAsSeen(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.exec(ctx, q.markFeedAsSeenStmt, markFeedAsSeen, pq.Array(dollar_1))
	return err
}

const removeObjectTypeValue = `-- name: RemoveObjectTypeValue :exec
DELETE FROM obj_type_value
WHERE obj_type_value.id = $1
AND EXISTS (
    SELECT 1 FROM obj o
    JOIN creator c ON o.creator_id = c.id
    WHERE o.id = obj_type_value.obj_id AND c.org_id = $2
)
`

type RemoveObjectTypeValueParams struct {
	ID    uuid.UUID `json:"id"`
	OrgID uuid.UUID `json:"org_id"`
}

func (q *Queries) RemoveObjectTypeValue(ctx context.Context, arg RemoveObjectTypeValueParams) error {
	_, err := q.exec(ctx, q.removeObjectTypeValueStmt, removeObjectTypeValue, arg.ID, arg.OrgID)
	return err
}

const removeObjectsFromFact = `-- name: RemoveObjectsFromFact :exec
DELETE FROM obj_fact
WHERE fact_id = $1 AND obj_id = ANY($2::uuid[])
`

type RemoveObjectsFromFactParams struct {
	FactID  uuid.UUID   `json:"fact_id"`
	Column2 []uuid.UUID `json:"column_2"`
}

func (q *Queries) RemoveObjectsFromFact(ctx context.Context, arg RemoveObjectsFromFactParams) error {
	_, err := q.exec(ctx, q.removeObjectsFromFactStmt, removeObjectsFromFact, arg.FactID, pq.Array(arg.Column2))
	return err
}

const removeObjectsFromTask = `-- name: RemoveObjectsFromTask :exec
DELETE FROM obj_task
WHERE task_id = $1 AND obj_id = ANY($2::uuid[])
`

type RemoveObjectsFromTaskParams struct {
	TaskID  uuid.UUID   `json:"task_id"`
	Column2 []uuid.UUID `json:"column_2"`
}

func (q *Queries) RemoveObjectsFromTask(ctx context.Context, arg RemoveObjectsFromTaskParams) error {
	_, err := q.exec(ctx, q.removeObjectsFromTaskStmt, removeObjectsFromTask, arg.TaskID, pq.Array(arg.Column2))
	return err
}

const removeTagFromObject = `-- name: RemoveTagFromObject :exec
DELETE FROM obj_tag
WHERE obj_id = $1 AND tag_id = $2
AND EXISTS (
    SELECT 1 FROM obj o
    JOIN creator c ON o.creator_id = c.id
    WHERE o.id = $1 AND c.org_id = $3
)
`

type RemoveTagFromObjectParams struct {
	ObjID uuid.UUID `json:"obj_id"`
	TagID uuid.UUID `json:"tag_id"`
	OrgID uuid.UUID `json:"org_id"`
}

func (q *Queries) RemoveTagFromObject(ctx context.Context, arg RemoveTagFromObjectParams) error {
	_, err := q.exec(ctx, q.removeTagFromObjectStmt, removeTagFromObject, arg.ObjID, arg.TagID, arg.OrgID)
	return err
}

const softDeleteObjStep = `-- name: SoftDeleteObjStep :exec
UPDATE obj_step
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteObjStep(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.softDeleteObjStepStmt, softDeleteObjStep, id)
	return err
}

const updateFact = `-- name: UpdateFact :one
UPDATE fact
SET text = $2, happened_at = $3, location = $4
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, text, happened_at, location, creator_id, created_at, last_updated, deleted_at
`

type UpdateFactParams struct {
	ID         uuid.UUID    `json:"id"`
	Text       string       `json:"text"`
	HappenedAt sql.NullTime `json:"happened_at"`
	Location   string       `json:"location"`
}

func (q *Queries) UpdateFact(ctx context.Context, arg UpdateFactParams) (Fact, error) {
	row := q.queryRow(ctx, q.updateFactStmt, updateFact,
		arg.ID,
		arg.Text,
		arg.HappenedAt,
		arg.Location,
	)
	var i Fact
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.HappenedAt,
		&i.Location,
		&i.CreatorID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const updateFunnel = `-- name: UpdateFunnel :one
UPDATE funnel
SET name = $2, description = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, description, creator_id, created_at, deleted_at
`

type UpdateFunnelParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
}

func (q *Queries) UpdateFunnel(ctx context.Context, arg UpdateFunnelParams) (Funnel, error) {
	row := q.queryRow(ctx, q.updateFunnelStmt, updateFunnel, arg.ID, arg.Name, arg.Description)
	var i Funnel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateObjStep = `-- name: UpdateObjStep :exec
UPDATE obj_step
SET step_id = $2
WHERE step_id = $1
`

type UpdateObjStepParams struct {
	StepID   uuid.UUID `json:"step_id"`
	StepID_2 uuid.UUID `json:"step_id_2"`
}

func (q *Queries) UpdateObjStep(ctx context.Context, arg UpdateObjStepParams) error {
	_, err := q.exec(ctx, q.updateObjStepStmt, updateObjStep, arg.StepID, arg.StepID_2)
	return err
}

const updateObjStepSubStatus = `-- name: UpdateObjStepSubStatus :exec
UPDATE obj_step
SET sub_status = $2
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateObjStepSubStatusParams struct {
	ID        uuid.UUID `json:"id"`
	SubStatus int32     `json:"sub_status"`
}

func (q *Queries) UpdateObjStepSubStatus(ctx context.Context, arg UpdateObjStepSubStatusParams) error {
	_, err := q.exec(ctx, q.updateObjStepSubStatusStmt, updateObjStepSubStatus, arg.ID, arg.SubStatus)
	return err
}

const updateObject = `-- name: UpdateObject :one
UPDATE obj
SET name = $2, description = $3, id_string = $4
WHERE id = $1
RETURNING id, name, description, id_string, creator_id, created_at, deleted_at
`

type UpdateObjectParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	IDString    string    `json:"id_string"`
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) (Obj, error) {
	row := q.queryRow(ctx, q.updateObjectStmt, updateObject,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IDString,
	)
	var i Obj
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IDString,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateObjectType = `-- name: UpdateObjectType :one
UPDATE obj_type
SET name = $2, description = $3, fields = $4, icon = $5
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, icon, description, fields, creator_id, created_at, deleted_at, fields_search
`

type UpdateObjectTypeParams struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Fields      json.RawMessage `json:"fields"`
	Icon        string          `json:"icon"`
}

func (q *Queries) UpdateObjectType(ctx context.Context, arg UpdateObjectTypeParams) (ObjType, error) {
	row := q.queryRow(ctx, q.updateObjectTypeStmt, updateObjectType,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Fields,
		arg.Icon,
	)
	var i ObjType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Icon,
		&i.Description,
		&i.Fields,
		&i.CreatorID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.FieldsSearch,
	)
	return i, err
}

const updateObjectTypeValue = `-- name: UpdateObjectTypeValue :one
UPDATE obj_type_value
SET type_values = $3::jsonb
WHERE obj_type_value.id = $1
  AND EXISTS (
    SELECT 1 FROM obj o
    JOIN creator c ON o.creator_id = c.id
    WHERE o.id = obj_type_value.obj_id AND c.org_id = $2
  )
RETURNING id, obj_id, type_id, type_values, created_at, last_updated, deleted_at, search_vector
`

type UpdateObjectTypeValueParams struct {
	ID      uuid.UUID       `json:"id"`
	OrgID   uuid.UUID       `json:"org_id"`
	Column3 json.RawMessage `json:"column_3"`
}

func (q *Queries) UpdateObjectTypeValue(ctx context.Context, arg UpdateObjectTypeValueParams) (ObjTypeValue, error) {
	row := q.queryRow(ctx, q.updateObjectTypeValueStmt, updateObjectTypeValue, arg.ID, arg.OrgID, arg.Column3)
	var i ObjTypeValue
	err := row.Scan(
		&i.ID,
		&i.ObjID,
		&i.TypeID,
		&i.TypeValues,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
		&i.SearchVector,
	)
	return i, err
}

const updateOrgDetails = `-- name: UpdateOrgDetails :one
UPDATE org
SET name = $2, profile = $3
WHERE id = $1
RETURNING id, name, profile, created_at, deleted_at
`

type UpdateOrgDetailsParams struct {
	ID      uuid.UUID       `json:"id"`
	Name    string          `json:"name"`
	Profile json.RawMessage `json:"profile"`
}

func (q *Queries) UpdateOrgDetails(ctx context.Context, arg UpdateOrgDetailsParams) (Org, error) {
	row := q.queryRow(ctx, q.updateOrgDetailsStmt, updateOrgDetails, arg.ID, arg.Name, arg.Profile)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Profile,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateStep = `-- name: UpdateStep :one
UPDATE step
SET name = $2, definition = $3, example = $4, action = $5, step_order = $6, last_updated = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, funnel_id, name, definition, example, action, step_order, created_at, last_updated, deleted_at
`

type UpdateStepParams struct {
	ID         uuid.UUID `json:"id"`
	Name       string    `json:"name"`
	Definition string    `json:"definition"`
	Example    string    `json:"example"`
	Action     string    `json:"action"`
	StepOrder  int32     `json:"step_order"`
}

func (q *Queries) UpdateStep(ctx context.Context, arg UpdateStepParams) (Step, error) {
	row := q.queryRow(ctx, q.updateStepStmt, updateStep,
		arg.ID,
		arg.Name,
		arg.Definition,
		arg.Example,
		arg.Action,
		arg.StepOrder,
	)
	var i Step
	err := row.Scan(
		&i.ID,
		&i.FunnelID,
		&i.Name,
		&i.Definition,
		&i.Example,
		&i.Action,
		&i.StepOrder,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tag
SET description = $2, color_schema = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, description, color_schema, org_id, created_at, deleted_at
`

type UpdateTagParams struct {
	ID          uuid.UUID       `json:"id"`
	Description string          `json:"description"`
	ColorSchema json.RawMessage `json:"color_schema"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.queryRow(ctx, q.updateTagStmt, updateTag, arg.ID, arg.Description, arg.ColorSchema)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ColorSchema,
		&i.OrgID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE task
SET content = $2,
    deadline = $3,
    remind_at = $4,
    status = $5,
    assigned_id = $6,
    parent_id = $7,
    last_updated = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, content, deadline, remind_at, status, creator_id, assigned_id, parent_id, created_at, last_updated, deleted_at
`

type UpdateTaskParams struct {
	ID         uuid.UUID     `json:"id"`
	Content    string        `json:"content"`
	Deadline   sql.NullTime  `json:"deadline"`
	RemindAt   sql.NullTime  `json:"remind_at"`
	Status     string        `json:"status"`
	AssignedID uuid.NullUUID `json:"assigned_id"`
	ParentID   uuid.NullUUID `json:"parent_id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.queryRow(ctx, q.updateTaskStmt, updateTask,
		arg.ID,
		arg.Content,
		arg.Deadline,
		arg.RemindAt,
		arg.Status,
		arg.AssignedID,
		arg.ParentID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Deadline,
		&i.RemindAt,
		&i.Status,
		&i.CreatorID,
		&i.AssignedID,
		&i.ParentID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE creator
SET pwd = $2
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID  uuid.UUID `json:"id"`
	Pwd string    `json:"pwd"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.exec(ctx, q.updateUserPasswordStmt, updateUserPassword, arg.ID, arg.Pwd)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE creator
SET profile = $2
WHERE id = $1
RETURNING id, username, pwd, profile, role, org_id, active, created_at, deleted_at
`

type UpdateUserProfileParams struct {
	ID      uuid.UUID       `json:"id"`
	Profile json.RawMessage `json:"profile"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (Creator, error) {
	row := q.queryRow(ctx, q.updateUserProfileStmt, updateUserProfile, arg.ID, arg.Profile)
	var i Creator
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserRoleAndStatus = `-- name: UpdateUserRoleAndStatus :one
UPDATE creator
SET role = $2, active = $3
WHERE id = $1 AND org_id = $4
RETURNING id, username, pwd, profile, role, org_id, active, created_at, deleted_at
`

type UpdateUserRoleAndStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Role   string    `json:"role"`
	Active bool      `json:"active"`
	OrgID  uuid.UUID `json:"org_id"`
}

func (q *Queries) UpdateUserRoleAndStatus(ctx context.Context, arg UpdateUserRoleAndStatusParams) (Creator, error) {
	row := q.queryRow(ctx, q.updateUserRoleAndStatusStmt, updateUserRoleAndStatus,
		arg.ID,
		arg.Role,
		arg.Active,
		arg.OrgID,
	)
	var i Creator
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Pwd,
		&i.Profile,
		&i.Role,
		&i.OrgID,
		&i.Active,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}
